# 고득점 키트 - 탐욕법 Level 2 : 조이스틱 문제
# 목표 문자열이 주어지고, 그 녀석과 길이가 같은 'A'로만 구성된 문자열이 있다고 하자
# 조이스틱을 조작해 목표 문자열을 만들 수 있는 가장 짧은 횟수는?

# 1. 무식한 접근
# 한 문자를 일단 수정했다. 그 다음에 수정할 문자를 정하는 방법은 두 개다.
# 1) 왼쪽에 있는 문자를 고른다.(왼쪽 문자 중 수정 안 한 문자 중에서 최초로 나오는 놈)
# 2) 오른쪽에 있는 문자를 고른다.(오른쪽 문자 중 수정 안 한 문자 중에서 최초로 나오는 놈)
# 즉 문자의 길이가 N일때, N - 1번의 선택만 하면 모든 문자를 수정할 수 있다. 이 N - 1번의 선택은
# 각 선택을 좌로 하냐 우로 하냐에 따라 여러 조합이 나오는데, 이 모든 조합 중 가장 작은 값을 갖는
# 놈을 찾으면 그게 정답이 되겠다. (러프하게 생각한 것임. 실제로 항상 오른쪽 왼쪽을 둘 사 선택할 수
# 없는 게, 왼쪽으로 초과하면 오른쪽 수로 갈 수 있지만 오른쪽으로 초과하면 왼쪽으로 갈 수가 없음)
# 이 경우 2^(N - 1)정도의 조합이 나오는데 N은 최대 20이므로 2^19개의 조합을 살피게 됨.
# 대략 52만번 정도의 연산을 하며, 이 방식으로 풀이해도 1초 내에 통과가 가능할 것이다.

# 2. 더욱 더 빠르게 해보자. DP or Greedy일 텐데, 우선 부분문제로 쪼갤 수 있을까?
# 첫 문자를 수정하고, 왼쪽에 있는 문자를 수정하는 경우와 오른쪽에 나오는 문자를 수정하는 경우
# 둘 중 더 작은 값을 취하는 쪽으로 쪼갤 수 있다.

# 3. 중복되는 케이스 있는가? 있으면 DP로 풀이가 가능할 텐데
# 있긴 있다. 
# 1) 첫 문자 수정 후 왼쪽 문자 수정하고 오른쪽 문자 수정한 케이스
# 2) 첫 문자 수정 후 오른쪽 문자 수정하고 왼쪽 문자 수정한 케이스
# 에 대해 남은 문자들이 같다. 그러나 커서 위치까지 고려한다면 같은 케이스로 보기 힘듦
# DP로 하기엔 많이 복잡쓰해보인다ㅎㅎ

# 4. 그리디 의심
# 우선 그리디 속성이 있는지에 대해 묻는다면 대답은 Yes. 내가 지금 왼쪽에 있는 문자를 고른다고 해서
# 다음 번 선택에서 왼쪽 문자를 못 고른다거나 그런 상황은 없다. 현재 선택이 다음번 선택에 영향을 주지
# 않는다고 볼 수 있으므로 탐욕적 선택 속성이 있다고 볼 수 있고, 지금 내리는 선택이 그 자체로 부분문제
# 가 되는 케이스에 역시 해댱된다.

# 우선 이 문제는 만들어야 할 문자열에 A가 하나도 없다면 오른쪽으로 쭉 가거나 왼쪽으로 쭉 가면 된다. 그러나 A가 있을
# 경우가 문제가 된다. A가 있다면 그 놈을 최대한 많이 안 지나가야 조이스틱 조작횟수가 줄어든다. 따라서 A가 있는 경우
# 그 때 그 때마다 적절히 왼쪽으로 갈지 오른쪽으로 갈지를 결정해야 한다. 이 때의 선택기준은 현재 내 커서위치에서
# 오른쪽에 있는 수정해야 할 문자로 가는 경우와 왼쪽에 있는 문자로 가야 할 경우 중 더 작은 값이 드는 쪽으로 한다.


def stick_add(a, num, max_size):
    a += num
    if a < 0 or a > max_size - 1:
        a = max_size - 1
    return a

def solution(name):
    answer = 0
    check = [0 for _ in range(len(name))]
    L, R, cur = 0, 0, 0
    change_count = 0

    if name[cur] != 'A':
        change_count += 1
        if name[cur] <= 'N':
            answer += (ord(name[cur]) - ord('A'))
        else:
            answer += (ord('Z') - ord(name[cur]) + 1)
        check[cur] += 1

    while change_count < len(name) - name.count('A'):
        move = 0
        while True:
            move += 1
            L = stick_add(L, -1, len(name))
            R = stick_add(R, 1, len(name))

            if not check[R] and name[R] != 'A':
                answer += move
                cur, L = R, R
                break
            if not check[L] and name[L] != 'A': 
                answer += move
                cur, R = L, L
                break
            

        change_count += 1
        if name[cur] <= 'N':
            answer += (ord(name[cur]) - ord('A'))
        else:
            answer += (ord('Z') - ord(name[cur]) + 1)
        check[cur] += 1   

    return answer
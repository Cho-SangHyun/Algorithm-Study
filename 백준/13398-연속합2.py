# 기존 연속합 문제는 O(N)의 시간이 걸림
# 원소 하나를 제거 가능한데 N은 최대 10만이므로
# 원소를 하나하나 제거하며 dp를 돌리면 N * O(N) = O(N^2) = 시간초과

# 원소를 제거하는 어떠한 방법이 필요
# 1. 음수만 제거대상이다. (그러나 음수가 몇 개만 나온다는 제약 X, 따라서 무용지물)
# 2. 제일 절댓값이 큰 음수를 제거 => 반례 :원소가 1, -2, 2, 2, 2, -3, -4처럼 되어있으면 
#    -2를 제거하는게 이득임

# 10 -4 3 1 5 6 -35 12 21 -1

# "수를 하나 제거할 수 있다"를 어떤 수를 빼야 하는 가가 아니라
# 연속된 수를 골라나갈 때 최대 한 개까지 건너뛸 수 있다는 관점으로 보기

# dp[x]를 똑같이 x번째 항으로 끝나는 최대연속합으로 보지만 이 문제에서는

# dp[x][0] = 아직 한 번도 건너뛴 적 없 없음
#            이 경우 기존 부분합 구하던 것처럼 dp[x][0] = max(dp[x - 1] + 자기자신, 자기자신)

# dp[x][1] = x - 2번째 항에서 건너뜀
#            이 경우 dp[x][1] = dp[x - 2][0] + 자기자신

# dp[x][2] = 이미 이전에 한 번 건너뛴 적 있음
#            이 경우 dp[x][2] = max(dp[x - 1][2] + 자기자신, dp[x - 1][1] + 자기자신)

# 다른 사람 풀이에선 1, 2를 하나로 묶음 그래서 케이스는 2개
# 1) 아직 건너뛴 적 없는 경우
# 2) 건너뛴 적 있는 경우

import sys

input = sys.stdin.readline

N = int(input())

data = [0] + list(map(int, input().split()))

dp = [[] for _ in range(100002)]
dp[0] = [-999999999, -999999999, -999999999]
dp[1] = [data[1], -999999999, -999999999]

for i in range(2, N + 1):
    dp[i] = [
        max(dp[i - 1][0] + data[i], data[i]), # 점프없이 이어지는 경우
        dp[i - 2][0] + data[i], # i - 2항에서 점프한 경우
        max(dp[i - 1][2] + data[i], dp[i - 1][1] + data[i]) # 기존에 점프를 한 경우의 최대
    ]

answer = -999999999

for i in range(1, N + 1):
    answer = max(answer, max(dp[i]))

print(answer)

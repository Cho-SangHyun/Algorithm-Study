# 1. 무식하게 접근
# 1부터 N짜리 길이의 수까지 하나하나 계단 수인지 따짐
# N이 8일 때 1억번 이상 계산한다는 것인데, N은 100까지주어지므로
# 이 방법으로 풀면 시간초과가 날 것임

# 2. dp 혹은 그리디로 해야 한다.

# 2.1 부분문제로 쪼갤 수 있는지?
# 길이가 N인 계단 수
# = 끝이 1로 끝나는 길이가 N-1인 계단수 뒤에 0을 붙인 것
#   끝이 0 또는 2로 끝나는 길이가 N-1인 계단수 뒤에 1을 붙인 것
#   끝이 1 또는 3으로 끝나는 길이가 N-1인 계단수 뒤에 2을 붙인 것
#   끝이 2 또는 4로 끝나는 길이가 N-1인 계단수 뒤에 3을 붙인 것
#   ...
#   끝이 8로 끝나는 길이가 N - 1인 계단수 뒤에 9를 붙인 것
# 이런 식으로 쪼갤 수 있음

# 2.2 중복되는 구조 있는지?
# ㅇㅇ 위에서 바로 직관적으로 보임

# 2.3 그럼 dp로구나~

N = int(input())

mod = 1000000000

dp = [[0]*10 for _ in range(102)]
dp[1] = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1]

for i in range(2, 102):
    dp[i][0] = dp[i - 1][1] % mod
    dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % mod
    dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % mod
    dp[i][3] = (dp[i - 1][2] + dp[i - 1][4]) % mod
    dp[i][4] = (dp[i - 1][3] + dp[i - 1][5]) % mod
    dp[i][5] = (dp[i - 1][4] + dp[i - 1][6]) % mod
    dp[i][6] = (dp[i - 1][5] + dp[i - 1][7]) % mod
    dp[i][7] = (dp[i - 1][6] + dp[i - 1][8]) % mod
    dp[i][8] = (dp[i - 1][7] + dp[i - 1][9]) % mod
    dp[i][9] = dp[i - 1][8] % mod

print(sum(dp[N]) % mod)


# A, B로만 구성된 문자열 S, T가 주어진다. T의 길이는 항상 S보다 길다.
# S에 다음과 같은 연산만 하여 T를 만들 수 있을까?

# 1. 뒤에 A붙이기
# 2. 뒤에 B붙이고 뒤집기

# 떠오르는 가장 간단한 방법
# 1을 하던 2를 하던 뒤에 한 알파벳씩 붙이는 거니까,각 스텝에서 1, 2를 하는 모든 결과들을 다 구해 T랑 맞는지 비교
# 즉 가지치기해나가는 방식 -> 2^49만큼의 연산을 할 수도 있음,,

# 결국 T를 만들 수 있다고 해도 마지막에 A붙이던가 B붙이고 뒤집던가임.
# T가 생긴 형태가 끝이 B로 끝나는데 처음이 A -> 못 만든다.
# T가 생긴 형태가 끝이 B로 끝나는데 처음이 B -> T[1:]를 뒤집은 문자열을 만들 수 있는지 판단해야 함
# T가 생긴 형태가 끝이 A로 끝나는데 처음이 A -> T[:-1]을 만들 수 있는지 판단해야 함
# T가 생긴 형태가 끝이 A로 끝나는데 처음이 B -> T[1:]를 뒤집은 문자열, T[:-1]을 만들 수 있는지 봐야 함

import sys
sys.setrecursionlimit(10**9)

def solution(S, T):
    if len(S) == len(T):
        if S == T:
            print(1)
            exit(0)
        return
    if T[-1] == "B":
        if T[0] == "B":
            solution(S, ''.join(reversed(T[1:])))
    else:
        if T[0] == "A":
            solution(S, T[:-1])
        else:
            solution(S, ''.join(reversed(T[1:])))
            solution(S, T[:-1])


S, T = input().rstrip(), input().rstrip()

solution(S, T)
print(0)

# 출발점에서 시작해 도착점까지 갈 수 있는지(이 문제처럼)는 도착점에서 시작해 출발점으로 갈 수 있는지
# 생각하면 풀리는 경우들이 꽤 있다

# 출발점에서 시작해 갈 수 있는 모든 길을 다 가보는 것보다는
# 도착점에서 시작해 도착점으로 "올 수 있는" 모든 길을 탐색하는 것이 좀 더 낫다. 

# 백트래킹 : 가지치기 형식으로 뻗어나가다가 이 길이 아니면 다시 이전 갈림길로 돌아와서 다른 갈림길로 감
#          -> DFS라고 볼 수 있다.
